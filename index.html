<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>node-evolve by daizoru</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>node-evolve</h1>
          <h2>A library for evolving programs - BETA</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/daizoru/node-evolve/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/daizoru/node-evolve/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/daizoru/node-evolve" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>node-evolve</h1>

<p>Programmatically evolve source code <em>BETA</em></p>

<h2>Summary</h2>

<p>Evolve is a library designed to explore parameters, algorithms and solutions automatically,
by introducing random changes in a program.</p>

<p>It works by mutating specific (or whole) parts of your code JavaScript ASTs, 
identified using a magic function:</p>

<div class="highlight"><pre><span class="nx">mutable</span>       <span class="nx">value</span>
<span class="nx">mutable</span> <span class="o">-&gt;</span>    <span class="nx">statements</span>
<span class="nx">mutable</span> <span class="o">-&gt;</span> <span class="o">-&gt;</span> <span class="nx">function</span>
</pre></div>

<p>Then a second function, "mutate()", will read your code (either statically, as a file, or dynamically, 
in the running process), and apply some mutations on it.</p>

<p>Theses mutations are probabilistic (you can adjust the mutation factor, and in the future, the mutation rules), 
and may modify the AST structure, statements, assignements, function calls, values and operations.</p>

<p>Node-evolve use a constraint system for early detection of impossible mutations, so
it should produce interesting results (?) most of the time.</p>

<p>Since there is absolutely no guarantee that your program will still work, or even "evaluate"
after mutation, you should use a higher-level library to manage individuals, population,
fitness and selection.</p>

<h2>Examples</h2>

<p>Please browse the <a href="https://github.com/daizoru/node-evolve/tree/master/examples" title="examples">examples</a> for a comprehensive tour of features and possible use cases.</p>

<h3>Self-replicating "bacteria"</h3>

<pre><code>$ coffee examples/medium/bacteria.coffee
</code></pre>

<p>Will run a minimalist demo program which can replicates itself (it just print a modified
 version of its own source code to the standard output).
To keep the demo simple, it is constrained to mutate only one thing - its own mutation rate:</p>

<div class="highlight"><pre><span class="nv">evolve = </span><span class="nx">require</span><span class="p">(</span><span class="s">'evolve'</span><span class="p">)</span>
<span class="nv">mutation_rate = </span><span class="mf">0.001</span>
<span class="nv">foo = </span><span class="p">.</span><span class="mi">20</span>
<span class="nx">evolve</span><span class="p">.</span><span class="nx">mutable</span> <span class="o">-&gt;</span>
  <span class="nv">foo = </span><span class="nx">foo</span> <span class="o">*</span> <span class="mf">0.10</span>
  <span class="nv">mutation_rate = </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
  <span class="nv">mutation_rate = </span><span class="nx">mutation_rate</span> <span class="o">/</span> <span class="nx">foo</span>
<span class="nx">evolve</span><span class="p">.</span><span class="nx">readFile</span>
  <span class="nv">ratio: </span><span class="nx">mutation_rate</span>
  <span class="nv">file: </span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="nv">debug: </span><span class="kc">false</span>
  <span class="nv">onComplete: </span><span class="nf">(src) -&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="nx">src</span>
</pre></div>

<h2>WARNING</h2>

<p>node-evolve is still in development and won't solve all problems for you:
  no matter how powerful it might looks like, you still have to design your program - and model your problem - carefully.</p>

<h2>Installation</h2>

<p>To install it as a dependency of your program, just type:</p>

<pre><code>$ npm install evolve
</code></pre>

<p>To install it globally, and benefit from the <em>evolve</em> commandline script, do:</p>

<pre><code>$ npm install -g evolve
</code></pre>

<h2>Introduction / Overview / features</h2>

<h3>Built-in mutation rules</h3>

<p>Various mutations are already available in node-evolve:
random insert, replace, delete of AST nodes, numbers, strings..</p>

<h3>Constrained syntax and semantics</h3>

<p>node-evolve will try hard to avoid useless or bad mutations - your code will already have a hard time surviving its first eval() anyway!</p>

<p>It works thanks to AST constraints.
These constraints prevent mutating this:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">/</span> <span class="nx">y</span><span class="p">;</span>
</pre></div>

<p>To this:</p>

<div class="highlight"><pre><span class="kd">var</span> <span class="mi">3</span> <span class="o">=</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">/</span><span class="p">;</span>
</pre></div>

<p>Because it would violates three constraints (assign to a number,
lone '/' and '*' operators..)</p>

<p>But for instance, this mutation would be allowed: </p>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span> <span class="o">+</span> <span class="mi">4</span> <span class="p">;</span>
</pre></div>

<p>In the end, all these constraints make mutation more efficient,
by avoiding running a "compilation" step or evaluation on obviously bad code. It saves time.</p>

<h3>Customizable rules</h3>

<p>You can input your own rules, if they can be applied to an AST node (or the root node of the whole tree).</p>

<h3>Simple type checking</h3>

<p>node-evolve check that incompatible references are not mixed.</p>

<p>For instance, if you define this context:</p>

<div class="highlight"><pre><span class="nv">context = </span><span class="o">-&gt;</span> <span class="p">[</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span> <span class="p">]</span>
</pre></div>

<p>then this mutation can't happen with node-evolve:</p>

<div class="highlight"><pre><span class="nx">var</span> <span class="nv">x = </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">;</span>
</pre></div>

<p>But this one can:</p>

<div class="highlight"><pre><span class="nx">var</span> <span class="nv">x = </span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">);</span>
</pre></div>

<p>On the other hand, this one is prohibited:</p>

<div class="highlight"><pre><span class="nb">Math</span><span class="p">.</span><span class="nv">PI = </span><span class="nx">x</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</pre></div>

<p>Since variables and functions passed in context are read-only</p>

<h2>Documentation</h2>

<h3>Best practices</h3>

<p>You can combine markers (annotation functions) with mutation of genetic rules,
  to mutate the mutation process itself. </p>

<p>It's very easy and you should really do that if you want to converge to a result faster.</p>

<p>See an example here <a href="https://github.com/daizoru/node-evolve/tree/master/examples/medium/mutations" title="here">here</a>.</p>

<h3>List of supported mutations</h3>

<h4>Numerical values</h4>

<p>Numerical values are subject to mutation, like random multiplication or addition.</p>

<h4>Binary operator substitution</h4>

<p>Operator of binary operations may be substituted by any operator
  of this list: + - * /</p>

<h4>Binary operator switching</h4>

<p>This mutation simply switch two terms of an operation,
  eg. 10.0 / 5.0 becomes 5.0 / 10.0. </p>

<h4>EXPERIMENTAL - String mutation, levenshtyle.</h4>

<p>String mutation is supported, and done using atomic operators like add, delete, move and substitution. However it is still experimental, and doesn't offer
  much control over which ASCII characters are allowed, forbidden,
  constants strings, collections of strings.. you have to implement this
  yourself for the moment (using Rules)</p>

<h4>EXPERIMENTAL - Block copying, cutting &amp; pasting</h4>

<p>This mutation copy or cut a node of the AST tree to another place.
  It may replace a node or insert between two.</p>

<h4>EXPERIMENTAL - Variable substitution</h4>

<p>Any variable is subject to change and remplacement by another variable.</p>

<h4>EXPERIMENTAL - Support for multiples iterations</h4>

<p>It can apply more than one layer of mutation:
For instance, one iteration might copy AST nodes to a buffer,
and another may paste the content to overwrite or insert data.</p>

<p>Use this feature to create complex, combined mutations.</p>

<h2>How-to</h2>

<h3>Use it in command line</h3>

<pre><code>$ evolve src [ratio=0.42] [debug]
</code></pre>

<p>Example :</p>

<pre><code>$ evolve examples/basic/with_mutable.js ratio=0.10
</code></pre>

<div class="highlight"><pre><span class="nx">mutable</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">y</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">z</span> <span class="o">=</span> <span class="s2">"hello"</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">c</span> <span class="o">=</span> <span class="mf">1.4881885522045195</span> <span class="o">*</span> <span class="nx">z</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<h3>Using the API</h3>

<h4>Defining a mutable value</h4>

<div class="highlight"><pre><span class="p">{</span><span class="nx">mutable</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="s">'evolve'</span>

<span class="c1"># x is now a mutable: it's definition may by readable and evolvable</span>
<span class="c1"># using node-evolve parser</span>
<span class="nv">x = </span><span class="nx">mutable</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>

<div class="highlight"><pre><span class="p">{</span><span class="nx">mutable</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="s">'evolve'</span>

<span class="k">class</span> <span class="nx">Foo</span>

  <span class="nv">constructor: </span><span class="o">-&gt;</span>

  <span class="nv">foo: </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="o">=&gt;</span>

    <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># define a block of evolvable code, algorithm, neural network..</span>
    <span class="nx">mutable</span> <span class="o">-&gt;</span>

      <span class="c1"># the evolved code can only mess with foo()'s variables</span>
      <span class="c1"># if evolution goes wrong</span>
      <span class="nv">a = </span><span class="nx">x</span> <span class="o">*</span> <span class="mi">1</span>
      <span class="nv">b = </span><span class="nx">y</span> <span class="o">*</span> <span class="mi">1</span>
      <span class="nv">c = </span><span class="nx">z</span> <span class="o">*</span> <span class="mi">1</span>

      <span class="c1"># you can add an "hidden" level of memory</span>
      <span class="nv">f = </span><span class="mi">5</span>
      <span class="nv">g = </span><span class="mi">42</span> 

      <span class="c1"># and maths!</span>
      <span class="nv">b = </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span> <span class="nx">a</span><span class="p">)</span>
      <span class="nv">c = </span><span class="nx">a</span> <span class="o">+</span> <span class="mi">3</span>

    <span class="c1"># outside the block, you can call your stuff as usual</span>
    <span class="nx">@bar</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span>

</pre></div>

<h4>Defining a mutable function</h4>

<div class="highlight"><pre><span class="nv">evolve = </span><span class="nx">require</span> <span class="s">'evolve'</span>

<span class="k">class</span> <span class="nx">Foo</span>

  <span class="nv">constructor: </span><span class="o">-&gt;</span>

  <span class="nv">foo: </span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">,</span><span class="nx">z</span><span class="p">)</span> <span class="o">=&gt;</span>

    <span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># define a block of evolvable code, algorithm, neural network..</span>
    <span class="nv">func = </span><span class="nx">evolve</span><span class="p">.</span><span class="nx">mutable</span> <span class="o">-&gt;</span> <span class="o">-&gt;</span>

      <span class="c1"># the evolved code can only mess with foo()'s variables</span>
      <span class="c1"># if evolution goes wrong</span>
      <span class="nv">a = </span><span class="nx">x</span> <span class="o">*</span> <span class="mi">1</span>
      <span class="nv">b = </span><span class="nx">y</span> <span class="o">*</span> <span class="mi">1</span>
      <span class="nv">c = </span><span class="nx">z</span> <span class="o">*</span> <span class="mi">1</span>

      <span class="c1"># you can add an "hidden" level of memory</span>
      <span class="nv">f = </span><span class="mi">5</span>
      <span class="nv">g = </span><span class="mi">42</span> 

      <span class="c1"># and maths!</span>
      <span class="nv">b = </span><span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span><span class="p">(</span><span class="nx">g</span> <span class="o">*</span> <span class="nx">a</span><span class="p">)</span>
      <span class="nv">c = </span><span class="nx">a</span> <span class="o">+</span> <span class="mi">3</span>

    <span class="nx">func</span><span class="p">()</span>

    <span class="c1"># outside the block, you can call your stuff as usual</span>
    <span class="nx">@bar</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span>

</pre></div>

<h4>Dynamic mutation of the currently running program (CoffeeScript example)</h4>

<div class="highlight"><pre><span class="p">{</span><span class="nx">mutate</span><span class="p">}</span> <span class="o">=</span> <span class="nx">require</span> <span class="s">'evolve'</span>

<span class="nx">evolve</span><span class="p">.</span><span class="nx">mutate</span> 
  <span class="nv">obj: </span><span class="nx">Foo</span><span class="p">.</span><span class="nx">prototype</span>
  <span class="nv">func: </span><span class="s">'foo'</span>
  <span class="nv">onComplete: </span><span class="o">-&gt;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="s">"mutation of foo() completed."</span>

    <span class="nv">f = </span><span class="k">new</span> <span class="nx">Foo</span><span class="p">()</span>
    <span class="nx">f</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span>
</pre></div>

<h4>Static mutation of a source string (JavaScript Example)</h4>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">evolve</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">"evolve"</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">old_src</span> <span class="o">=</span> <span class="s2">"x1 = 0; x2 = 42; f1 = function() { return x2 * 10; }; x1 = f1();"</span><span class="p">;</span>

<span class="c1">// clone a source, with some "dna" copy errors</span>
<span class="nx">evolve</span><span class="p">.</span><span class="nx">clone</span><span class="p">({</span>

  <span class="c1">// input source code (string)</span>
  <span class="s2">"src"</span> <span class="o">:</span> <span class="nx">old_src</span><span class="p">,</span>

  <span class="s2">"tentatives"</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>

  <span class="c1">// on complete always return a source; In case of failure, the original is returned</span>
  <span class="s2">"onComplete"</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"finished: "</span> <span class="o">+</span> <span class="nx">src</span><span class="p">);</span> <span class="p">}</span>
<span class="p">});</span>

</pre></div>

<h4>Static mutation of a source file (JavaScript example)</h4>

<p>The input file can be in .js or in .coffee</p>

<div class="highlight"><pre>
<span class="c1">// read a file, with some "dna" copy errors</span>
<span class="nx">evolve</span><span class="p">.</span><span class="nx">readFile</span><span class="p">({</span>
    <span class="s2">"file"</span> <span class="o">:</span> <span class="s2">"examples/evolvable.js"</span><span class="p">,</span>
    <span class="s2">"onComplete"</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">src</span><span class="p">);</span> <span class="p">}</span>
<span class="p">});</span>

</pre></div>

<h4>Customization of globals</h4>

<p>Just pass a bunch of variables to be used in mutations.
these variables must be returned by a function,
for symbol name introspection to work</p>

<div class="highlight"><pre>
<span class="nv">context = </span><span class="o">-&gt;</span> <span class="p">[</span>
  <span class="nb">Math</span><span class="p">.</span><span class="nx">cos</span>
  <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span>
  <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span>
  <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span>
<span class="p">]</span>

<span class="c1"># then call it</span>
<span class="nx">evolve</span><span class="p">.</span><span class="nx">mutate</span> <span class="nv">context: </span><span class="nx">context</span><span class="p">,</span> <span class="p">.....</span>
</pre></div>

<h4>Customize the mutation rules</h4>

<p>For the moment, please refer to the <a href="https://github.com/daizoru/node-evolve/blob/master/src/rules.coffee" title="sources">sources</a> to see how rules work</p>

<div class="highlight"><pre><span class="nv">rules =</span>

  <span class="c1"># decorators are applied on each node, and expected to return either</span>
  <span class="c1"># the current, new or modified node, or an undefined value (then it is ignored)</span>
  <span class="nv">decorators:</span>
    <span class="nv">multiply: </span><span class="nf">(t, value) -&gt;</span> 
      <span class="k">if</span> <span class="nx">t</span> <span class="o">is</span> <span class="s">'num'</span> <span class="o">and</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">then</span> <span class="p">[</span><span class="nx">t</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">value</span><span class="p">]</span>


</pre></div>

<h2>Change log</h2>

<h3>0.0.2</h3>

<ul>
<li>revert back to just the 'mutable' keyword</li>
<li>various bigfixes</li>
<li>more examples</li>
<li>still slow as hell - maybe use another parsing library?</li>
</ul><h3>0.0.1</h3>

<ul>
<li>?</li>
</ul><h3>0.0.0</h3>

<ul>
<li>initial commit</li>
</ul><h2>License (BSD)</h2>

<pre lang="plain"><code>Copyright (c) 2012, Julian Bilcke &lt;julian.bilcke@daizoru.com&gt;
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met: 

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer. 
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies, 
either expressed or implied, of Julian Bilcke.
</code></pre>
        </section>

        <footer>
          node-evolve is maintained by <a href="https://github.com/daizoru">daizoru</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

                  <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-35909229-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

      </div>
    </div>
  </body>
</html>