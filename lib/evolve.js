// Generated by CoffeeScript 1.4.0
(function() {
  var P, async, clone, copy, cs2js, deck, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, js2cs, jsp, main, makeRules, mutable, mutate, mutateSync, path, pretty, pro, readFile, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  inspect = require('util').inspect;

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  cs2js = require('../node_modules/coffee-script').compile;

  js2cs = require('../node_modules/js2coffee/lib/js2coffee').build;

  async = require('ragtime').async;

  deck = require('deck');

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  makeRules = require('./rules').makeRules;

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  exports.clone = clone = function(opts) {
    var globals, i, inlinePaths, item, items, k, mutateBranch, mutateTree, mutations, name, options, reservoir_ast, resolve, v, work, _i, _len, _ref;
    options = {
      src: "",
      ratio: 0.01,
      iterations: 2,
      pretty: true,
      debug: false,
      ignore_var: false,
      isCoffee: false,
      inlinePath: ["."],
      context: function() {
        return [Math.abs, Math.acos, Math.asin, Math.atan, Math.atan2, Math.ceil, Math.cos, Math.exp, Math.floor, Math.log, Math.max, Math.min, Math.pow, Math.random, Math.round, Math.sin, Math.sqrt, Math.tan, Math.PI];
      }
    };
    globals = {
      callables: [],
      readables: [],
      writables: []
    };
    mutations = 0;
    resolve = function(item) {
      var name, sub;
      name = "";
      if (item[0] === 'dot') {
        sub = "";
        if (isArray(item[1])) {
          sub = "" + resolve(item[1]);
        } else {
          sub = item[1][1];
        }
        name = "" + sub + "." + item[2];
      } else if (item[0] === 'name') {
        name = item[1];
      }
      return name;
    };
    items = [];
    try {
      reservoir_ast = jsp.parse("RESERVOIR = " + (options.context.toString()) + ";", {});
      items = reservoir_ast[1][0][1][3][3][0][1][1];
      if (options.debug) {
        console.log("imported context:");
      }
    } catch (e) {
      console.log("couldn't run static analysis of context: " + e);
    }
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      name = resolve(item);
      i = void 0;
      try {
        i = eval(name);
      } catch (e) {
        console.log("error when checking " + name + ": " + e);
        continue;
      }
      if (isFunction(i)) {
        if (options.debug) {
          console.log(" - " + name + " is a function");
        }
        globals.callables.push(name);
      } else if (isArray(i)) {
        if (options.debug) {
          console.log(" - " + name + " is an array - not supported yet");
        }
      } else if (isNumber(i)) {
        if (options.debug) {
          console.log(" - " + name + " is a number");
        }
        globals.readables.push(name);
      } else {
        if (options.debug) {
          console.log(" - type of " + name + " couldn't be found (value: " + i + ")");
        }
      }
    }
    for (k in opts) {
      v = opts[k];
      if (k !== 'rules') {
        options[k] = v;
      }
    }
    work = {};
    work.old_src = options.src;
    if (options.debug) {
      console.log("old_src: " + work.old_src);
    }
    inlinePaths = (_ref = options.inlinePath) != null ? _ref : ["."];
    if (options.isCoffee) {
      work.old_src = cs2js(work.old_src, {
        bare: true
      });
      if (options.debug) {
        console.log("old_src: " + work.old_src);
      }
    }
    try {
      work.old_ast = jsp.parse(work.old_src, {});
    } catch (e1) {
      if (e1.message === 'Unexpected token: punc (()') {
        try {
          work.old_ast = jsp.parse("var ROOT = " + work.old_src + ";", {});
          work.old_ast[1][0] = work.old_ast[1][0][1][0][1];
        } catch (e2) {
          console.log(e2.message);
          console.log("function wrapping failed: " + e1.message);
          return;
        }
      } else {
        console.log("unsupported parsing error: " + e1.message);
      }
    }
    mutateBranch = function(branch) {
      var clipboard, locals, rules, transform, _j, _ref1;
      locals = {
        callables: [],
        readables: [],
        writables: []
      };
      clipboard = [];
      /*
          analyze = (parent=[branch], id=0) ->
            console.log "analyze(#{parent},#{id})"
            console.log "checking: " + pretty parent[id]
            if isArray parent[id]
              type = parent[id][0] 
              if type is 'var'
                for w in parent[id][1]
                  writable = ['name', w]
                  locals.writables.push writable
              else if type is 'assign'
                writable = copy parent[id][2] # might be a name or a dot
                locals.writables.push writable
              for i in [0...parent[id].length]
                analyze parent[id], i
      */

      rules = makeRules(options, globals, locals, clipboard);
      transform = function(parent, id) {
        var res, rule, type, _j, _ref1, _results;
        if (isArray(parent[id])) {
          type = parent[id][0];
          for (name in rules) {
            rule = rules[name];
            res = rule.apply(null, parent[id]);
            if (isArray(res)) {
              mutations += 1;
              parent[id] = res;
            }
          }
          _results = [];
          for (i = _j = 0, _ref1 = parent[id].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(transform(parent[id], i++));
          }
          return _results;
        }
      };
      for (i = _j = 0, _ref1 = options.iterations; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        if (options.debug) {
          console.log("ITERATION " + i);
        }
        transform([branch], 0);
        if (options.debug) {
          console.log("new branch: " + pretty(branch));
        }
      }
      return branch;
    };
    mutateTree = function(tree) {
      var branch, found, searchInline, searchMutables;
      found = false;
      (searchInline = function(node) {
        var file, filePath, iast, inlined, isrc, n, _j, _len1, _ref1, _results;
        if (isArray(node)) {
          i = -1;
          _results = [];
          for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
            n = node[_j];
            i++;
            if (!isArray(n)) {
              continue;
            }
            inlined = false;
            if (n[0] === 'call') {
              if ((_ref1 = "" + n[1]) === 'dot,name,evolve,inline' || _ref1 === 'name,inline') {
                inlined = true;
              }
            }
            if (inlined) {
              file = n[2][0][1];
              filePath = path.normalize("" + inlinePaths[0] + "/" + file + ".js");
              isrc = fs.readFileSync(filePath);
              iast = jsp.parse("function(){" + isrc + "}();", {});
              _results.push(node[i] = iast);
            } else {
              _results.push(searchInline(n));
            }
          }
          return _results;
        }
      })(tree);
      (searchMutables = function(node) {
        var n, _j, _k, _len1, _len2, _ref1, _results, _results1;
        if (isArray(node)) {
          if (node[0] === 'call') {
            if ((_ref1 = "" + node[1]) === 'dot,name,evolve,mutable' || _ref1 === 'name,mutable') {
              found = true;
              return node[2][0][3] = mutateBranch(copy(node[2][0][3]));
            } else {
              _results = [];
              for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
                n = node[_j];
                _results.push(searchMutables(n));
              }
              return _results;
            }
          } else {
            _results1 = [];
            for (_k = 0, _len2 = node.length; _k < _len2; _k++) {
              n = node[_k];
              _results1.push(searchMutables(n));
            }
            return _results1;
          }
        }
      })(tree);
      if (!found) {
        branch = void 0;
        try {
          branch = tree;
        } catch (e) {
          if (options.debug) {
            console.log("couldn't find first function, aborting: " + e);
          }
        }
        if (branch) {
          if (options.debug) {
            console.log("found function! mutating it..");
          }
          tree = mutateBranch(copy(branch));
        } else {
          if (options.debug) {
            console.log("could not find branch");
          }
        }
      }
      return tree;
    };
    if (options.debug) {
      console.log("old AST: " + (inspect(work.old_ast, false, 20, true)) + "\n\n\n\n");
    }
    work.new_ast = mutateTree(copy(work.old_ast));
    if (options.isCoffee) {
      try {
        if (work.new_ast[1][0][0] === 'var') {
          work.new_ast[1].shift();
        }
      } catch (e) {
        if (options.debug) {
          console.log("no var? good thing? " + e);
        }
      }
    }
    if (options.debug) {
      console.log("new AST: " + (inspect(work.new_ast, false, 20, true)));
    }
    if (options.debug) {
      console.log("applied " + mutations + " mutations. generating code..");
    }
    work.new_src = pro.gen_code(work.new_ast, {
      beautify: options.pretty,
      indent_start: 0,
      indent_level: 4,
      quote_keys: false,
      space_colon: false
    });
    if (options.isCoffee) {
      work.new_src = js2cs(work.new_src, {
        no_comments: false
      });
    }
    options.onComplete(work.new_src);
    return work.new_src;
  };

  exports.mutateSync = mutateSync = function(input) {
    var i, k, options, v, _i, _len, _results;
    options = {
      src: "",
      isCoffee: false,
      debug: false,
      ratio: 0.10,
      inlinePath: '.'
    };
    if (isFunction(input)) {
      options.src = input.toString();
      return console.options;
    } else if (isString(input)) {
      options.src = input;
      return clone(options);
    } else if (isArray(input)) {
      _results = [];
      for (_i = 0, _len = input.length; _i < _len; _i++) {
        i = input[_i];
        options.src = i;
        _results.push(clone(options));
      }
      return _results;
    } else {
      for (k in input) {
        v = input[k];
        options[k] = v;
      }
      return function(f) {
        var curry, _j, _len1, _results1;
        options.src = "";
        curry = false;
        if (isFunction(input)) {
          options.src = input.toString();
          return console.options;
        } else if (isString(input)) {
          options.src = input;
          return clone(options);
        } else if (isArray(input)) {
          _results1 = [];
          for (_j = 0, _len1 = input.length; _j < _len1; _j++) {
            i = input[_j];
            options.src = i;
            _results1.push(clone(options));
          }
          return _results1;
        } else {
          throw new Error("unsupported input");
          return "";
        }
      };
    }
  };

  exports.mutate = mutate = function(obj, func, options) {
    var _ref, _ref1, _ref2, _ref3, _ref4;
    if (options == null) {
      options = {};
    }
    return clone({
      src: obj[func].toString(),
      isCoffee: (_ref = options.isCoffee) != null ? _ref : false,
      debug: (_ref1 = options.debug) != null ? _ref1 : false,
      ratio: (_ref2 = options.ratio) != null ? _ref2 : 0.01,
      iterations: (_ref3 = options.iterations) != null ? _ref3 : 2,
      inlinePath: (_ref4 = options.inlinePath) != null ? _ref4 : ['.'],
      onComplete: function(new_src) {
        var newFunction;
        if (options.debug) {
          console.log("obj[func] = " + new_src + ";");
        }
        newFunction = eval("obj[func] = " + new_src + ";");
        if (options.debug) {
          console.log("replaced function with " + newFunction);
        }
        obj[func] = newFunction;
        return options.onComplete();
      }
    });
  };

  exports.readFile = readFile = function(opts) {
    var k, options, v;
    options = {
      file: '',
      encoding: 'utf-8',
      debug: false,
      ratio: 0.01,
      iterations: 1,
      inlinePath: ['.'],
      onError: function(err) {}
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    return fs.readFile(options.file, options.encoding, function(err, src) {
      var isCoffee;
      if (err) {
        console.log("couldn't load file: " + err);
        async(function() {
          return options.onError(err);
        });
        return;
      }
      isCoffee = options.file.slice(-7) === ".coffee";
      return clone({
        src: src,
        isCoffee: isCoffee,
        debug: options.debug,
        ratio: options.ratio,
        iterations: options.iterations,
        inlinePath: options.inlinePath,
        onComplete: function(new_src) {
          return options.onComplete(new_src);
        }
      });
    });
  };

  exports.mutable = mutable = function(f) {
    if (isFunction(f)) {
      return f();
    } else {
      return f;
    }
  };

  exports.cli = main = function() {
    var a, args, config, debug, encoding, file, inlinePath, iterations, nb_args, ratio, _i, _len;
    args = process.argv;
    nb_args = args.length;
    file = args[2];
    debug = __indexOf.call(args, 'debug') >= 0;
    pretty = __indexOf.call(args, 'pretty') >= 0;
    encoding = 'utf-8';
    ratio = 0.10;
    iterations = 1;
    inlinePath = ['.'];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (a.lastIndexOf('ratio=', 0) === 0) {
        ratio = Number(a.slice(6));
      }
    }
    config = {
      debug: debug,
      pretty: pretty,
      encoding: encoding,
      ratio: ratio,
      iterations: iterations,
      inlinePath: inlinePath
    };
    config.onComplete = function(src) {
      return console.log(src);
    };
    config.onError = function(err) {
      console.log("error: " + err);
      return process.exit(-1);
    };
    if (nb_args > 2) {
      config.file = file;
      return readFile(config);
    } else {
      config.src = fs.readFileSync('/dev/stdin').toString();
      return clone(config);
    }
  };

}).call(this);
