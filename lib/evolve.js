// Generated by CoffeeScript 1.3.3
(function() {
  var P, async, clone, copy, deck, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, mutable, mutate, pro, toAST;

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  fs = require('fs');

  inspect = require('util').inspect;

  async = require('ragtime').async;

  deck = require('deck');

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  exports.clone = clone = function(opts) {
    var clipboard, constant_tree, constant_tree_hook, k, mutableResult, mutable_tree, options, passOne, passTwo, searchMutable, v, work;
    options = {
      f: function() {},
      ratio: 0.5,
      pretty: true,
      reservoir: {
        functions: {
          'Math.cos': Math.cos,
          'Math.sin': Math.sin,
          'Math.random': Math.random
        },
        constants: {
          'Math.PI': Math.PI
        }
      }
    };
    options.rules = {
      decorators: {
        multiply: function(type, value) {
          if (type === 'num' && P(0.5)) {
            return [type, Math.random() * value];
          }
        },
        add: function(type, value) {
          if (type === 'num' && P(0.5)) {
            return [type, Math.random() + value];
          }
        },
        change_operator: function(type, operator, first, second) {
          var idx, operators;
          if (type === 'binary' && P(1.0)) {
            console.log("change operator for " + type + ", " + operator + ", " + first + ", " + second);
            operators = ['+', '-', '*', '/'];
            idx = operators.indexOf(operator);
            if (idx !== -1) {
              operators.splice(idx, 1);
            }
            return [type, deck.pick(operators), first, second];
          }
        },
        switch_terms: function(type, operator, first, second) {
          if (type === 'binary' && P(0.5)) {
            console.log("switching terms for " + type + ", " + operator + ", " + first + ", " + second);
            return [type, operator, second, first];
          }
        },
        delete_term: function(type, operator, first, second) {
          if (type === 'binary' && P(0.0)) {
            console.log("deleting term for " + type + ", " + operator + ", " + first + ", " + second);
            if (P(0.5)) {
              return first;
            } else {
              return second;
            }
          }
        },
        duplicate_term: function(type, operator, first, second) {
          var cpy;
          if (type === 'binary' && P(0.0)) {
            console.log("duplicate_term for " + type + ", " + operator + ", " + first + ", " + second);
            cpy = copy([type, operator, first, second]);
            if (P(0.5)) {
              return [type, operator, cpy, second];
            } else {
              return [type, operator, first, cpy];
            }
          }
        },
        change_read_variable: function(type, name, read_variables) {
          if (type === 'read_variable' && P(0.5)) {
            return [type, deck.pick(options.reservoir.constants)];
          }
        },
        change_write_variable: function(type, name, write_variables) {
          if (type === 'write_variable' && P(0.5)) {
            return [type, name];
          }
        }
      }
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    console.log("options: " + (inspect(options)));
    work = {
      old_func: options.f
    };
    work.old_src = work.old_func.toString();
    console.log("old_src: " + work.old_src);
    try {
      work.old_ast = jsp.parse("ENDPOINT = " + work.old_src + ";", {});
    } catch (e) {
      console.log(e.message);
    }
    console.log("old_ast: " + work.old_ast);
    work.reservoir = options.reservoir;
    clipboard = [];
    searchMutable = function(node) {
      var recursive, results;
      results = [];
      recursive = function(node) {
        var found, n, _i, _len, _results;
        if (isArray(node)) {
          found = false;
          if (node[0] === 'call') {
            if (node[1][0] === 'dot') {
              if (isArray(node[1][1])) {
                if (node[1][1][0] === 'name' && node[1][1][1] === 'evolve') {
                  if (node[1][2] === 'mutable') {
                    found = true;
                  }
                }
              }
            } else if (node[1][0] === 'name') {
              if (node[1][1] === 'mutable') {
                found = true;
              }
            }
          }
          if (found) {
            return results = [node, copy(node[2][0][3])];
          } else {
            _results = [];
            for (_i = 0, _len = node.length; _i < _len; _i++) {
              n = node[_i];
              _results.push(recursive(n));
            }
            return _results;
          }
        }
      };
      recursive(node);
      return results;
    };
    constant_tree = copy(work.old_ast);
    mutableResult = searchMutable(constant_tree);
    if (mutableResult.length > 0) {
      console.log("found mutable function: " + mutableResult[1]);
    } else {
      console.log("not found..");
      return;
    }
    constant_tree_hook = mutableResult[0], mutable_tree = mutableResult[1];
    passOne = function() {
      var recursive;
      recursive = function(parent, id) {
        var decorator, decoratorName, i, n, res, _i, _len, _ref, _ref1, _ref2, _results, _results1;
        console.log("in node " + parent[id]);
        if (isArray(parent[id])) {
          i = 0;
          _ref = parent[id];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            n = _ref[_i];
            recursive(parent[id], i++);
          }
        }
        if (isArray(parent[id])) {
          switch (parent[id][0]) {
            case 'num':
              _ref1 = options.rules.decorators;
              _results = [];
              for (decoratorName in _ref1) {
                decorator = _ref1[decoratorName];
                res = decorator.apply(null, parent[id]);
                if (!isUndefined(res)) {
                  _results.push(parent[id] = res);
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
              break;
            case 'binary':
              _ref2 = options.rules.decorators;
              _results1 = [];
              for (decoratorName in _ref2) {
                decorator = _ref2[decoratorName];
                res = decorator.apply(null, parent[id]);
                if (isArray(res)) {
                  console.log("result: type: " + res[0] + ", operator: " + res[1] + ", first: " + res[2] + ", second: " + res[3]);
                  _results1.push(parent[id] = res);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
          }
        }
      };
      recursive([mutable_tree], 0);
      return console.log("pass one");
    };
    passOne();
    passTwo = function() {
      return console.log("pass two");
    };
    passTwo();
    console.log("mutable_tree: " + (inspect(mutable_tree, false, 20, true)));
    console.log("modifying the original buffer tree..");
    constant_tree_hook[2][0][3] = mutable_tree;
    work.new_ast = copy(constant_tree);
    console.log("new_ast: " + (inspect(work.new_ast, false, 20, true)));
    console.log("generating code..");
    work.new_src = pro.gen_code(work.new_ast, {
      beautify: options.pretty,
      indent_start: 0,
      indent_level: 4,
      quote_keys: false,
      space_colon: false
    });
    work.new_func = eval(work.new_src);
    console.log("work terminated");
    return options.onComplete(work.new_func);
  };

  exports.mutate = mutate = function(options) {
    console.log("mutate options: " + (inspect(options)));
    return clone({
      f: options.obj[options.func],
      onComplete: function(newFunction) {
        console.log("replacing function with " + newFunction);
        options.obj[options.func] = newFunction;
        return options.onComplete();
      }
    });
  };

  exports.mutable = mutable = function(f) {
    return f();
  };

}).call(this);
