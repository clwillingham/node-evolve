// Generated by CoffeeScript 1.3.3
(function() {
  var P, async, clone, copy, deck, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, main, mutable, mutate, pro, readFile, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  fs = require('fs');

  inspect = require('util').inspect;

  async = require('ragtime').async;

  deck = require('deck');

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  exports.clone = clone = function(opts) {
    var clipboard, constant_tree, constant_tree_hook, i, item, items, k, mutableResult, mutable_tree, mutations, name, options, passOne, passTwo, reservoir_ast, resolve, searchMutable, v, work, _i, _len;
    options = {
      src: "",
      ratio: 0.001,
      pretty: true,
      debug: false,
      context: function() {
        return [Math.toto.cos, Math.sin, Math.random, Math.PI];
      },
      reservoir: {
        callables: [],
        constants: []
      },
      clipboard: [],
      rules: {
        decorators: {}
      }
    };
    resolve = function(item) {
      var name, sub;
      name = "";
      console.log("resolving " + (inspect(item)));
      if (item[0] === 'dot') {
        sub = "";
        if (isArray(item[1])) {
          sub = "" + resolve(item[1]);
        } else {
          sub = item[1][1];
        }
        name = "" + sub + "." + item[2];
      } else if (item[0] === 'name') {
        name = item[1];
      }
      return name;
    };
    items = [];
    try {
      reservoir_ast = jsp.parse("RESERVOIR = " + (options.context.toString()) + ";", {});
      items = reservoir_ast[1][0][1][3][3][0][1][1];
      console.log("imported context:");
    } catch (e) {
      console.log("couldn't run static analysis of context: " + e);
    }
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      name = resolve(item);
      i = void 0;
      try {
        i = eval(name);
      } catch (e) {
        console.log("error when checking " + name + ": " + e);
        continue;
      }
      if (isFunction(i)) {
        console.log(" - " + name + " is a function");
        options.reservoir.callables.push(name);
      } else if (isArray(i)) {
        console.log(" - " + name + " is an array - not supported yet");
      } else if (isNumber(i)) {
        console.log(" - " + name + " is a number");
        options.reservoir.constants.push(name);
      } else {
        console.log(" - type of " + name + " couldn't be found (value: " + i + ")");
      }
    }
    options.rules = {
      decorators: {
        multiply: function(type, value) {
          if (type === 'num' && P(options.ratio * 0.2)) {
            return [type, Math.random() * value];
          }
        },
        add: function(type, value) {
          if (type === 'num' && P(options.ratio * 0.2)) {
            return [type, Math.random() + value];
          }
        },
        change_operator: function(type, operator, a, b) {
          var idx, operators;
          if (type === 'binary' && P(options.ratio * 0.3)) {
            if (options.debug) {
              console.log("change operator for " + type + ", " + operator + ", " + a + ", " + b);
            }
            operators = ['+', '-', '*', '/'];
            idx = operators.indexOf(operator);
            if (idx !== -1) {
              operators.splice(idx, 1);
            }
            return [type, deck.pick(operators), a, b];
          }
        },
        switch_terms: function(type, operator, a, b) {
          if (type === 'binary' && P(options.ratio * 0.1)) {
            if (options.debug) {
              console.log("switching terms for " + type + ", " + operator + ", " + a + ", " + b);
            }
            return [type, operator, b, a];
          }
        },
        delete_term: function(type, operator, a, b) {
          if (type === 'binary' && P(options.ratio * 0.0)) {
            if (options.debug) {
              console.log("deleting term for " + type + ", " + operator + ", " + a + ", " + b);
            }
            if (P(0.5)) {
              return a;
            } else {
              return b;
            }
          }
        },
        duplicate_term: function(type, operator, a, b) {
          var cpy;
          if (type === 'binary' && P(options.ratio * 0.0)) {
            if (options.debug) {
              console.log("duplicate_term for " + type + ", " + operator + ", " + a + ", " + b);
            }
            cpy = copy([type, operator, a, b]);
            if (P(0.5)) {
              return [type, operator, cpy, b];
            } else {
              return [type, operator, a, cpy];
            }
          }
        },
        change_read_variable: function(type, name, read_variables) {
          if (type === 'read_variable' && P(options.ratio * 0.1)) {
            return [type, deck.pick(options.reservoir.constants)];
          }
        },
        change_write_variable: function(type, name, write_variables) {
          if (type === 'write_variable' && P(options.ratio * 0.1)) {
            return [type, name];
          }
        },
        copy_term: function(type, name, a, b) {
          var node;
          if (type === 'binary' && P(options.ratio * 0.1)) {
            node = copy([type, name, a, b]);
            if (options.debug) {
              console.log("copying " + (inspect(node)));
            }
            options.clipboard.push(node);
            return node;
          }
        },
        paste_replace: function(type, operator, a, b) {
          if (type === 'binary' && options.clipboard.length > 0) {
            options.clipboard[0];
            return options.clipboard.shift();
          }
        },
        paste_insert: function(type, operator, a, b) {
          var node, t;
          if (type === 'binary' && options.clipboard.length > 0) {
            node = options.clipboard[0];
            options.clipboard.shift();
            t = P(0.5) ? 2 : 3;
            node[t] = [type, operator, a, b];
            return node;
          }
        },
        mutate_string: function(type, value) {
          var c, c2, chars, new_chars, other_chars, r, _j, _len1;
          if (type === 'string' && P(options.ratio * 0.05)) {
            chars = value.split('');
            other_chars = "abcefghijklmnopqrstuvwxyz0123456789 ".split('');
            new_chars = [];
            r = function() {
              return chars[Math.round(Math.random() * other_chars.length)];
            };
            for (_j = 0, _len1 = chars.length; _j < _len1; _j++) {
              c = chars[_j];
              if (P(0.9)) {
                new_chars.push(c);
              } else {
                c2 = r();
                if (!isUndefined(c2)) {
                  new_chars.push(c2);
                }
              }
            }
            return ['string', new_chars.join('')];
          }
        }
      }
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    work = {};
    work.old_src = options.src;
    try {
      work.old_ast = jsp.parse("ENDPOINT = " + work.old_src + ";", {});
    } catch (e) {
      console.log(e.message);
    }
    work.context = options.context;
    clipboard = [];
    searchMutable = function(node) {
      var recursive, results;
      results = [];
      recursive = function(node) {
        var found, n, _j, _len1, _results;
        if (isArray(node)) {
          found = false;
          if (node[0] === 'call') {
            if (node[1][0] === 'dot') {
              if (isArray(node[1][1])) {
                if (node[1][1][0] === 'name' && node[1][1][1] === 'evolve') {
                  if (node[1][2] === 'mutable') {
                    found = true;
                  }
                }
              }
            } else if (node[1][0] === 'name') {
              if (node[1][1] === 'mutable') {
                found = true;
              }
            }
          }
          if (found) {
            return results = [node, copy(node[2][0][3])];
          } else {
            _results = [];
            for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
              n = node[_j];
              _results.push(recursive(n));
            }
            return _results;
          }
        }
      };
      recursive(node);
      return results;
    };
    constant_tree = copy(work.old_ast);
    mutableResult = searchMutable(constant_tree);
    if (mutableResult.length > 0) {

    } else {
      console.log("not found..");
      return;
    }
    constant_tree_hook = mutableResult[0], mutable_tree = mutableResult[1];
    mutations = 0;
    passOne = function() {
      var recursive;
      recursive = function(parent, id) {
        var decorator, decoratorName, n, res, _j, _len1, _ref, _ref1, _ref2, _results;
        if (isArray(parent[id])) {
          i = 0;
          _ref = parent[id];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            n = _ref[_j];
            recursive(parent[id], i++);
          }
        }
        if (isArray(parent[id])) {
          if ((_ref1 = parent[id][0]) === 'num' || _ref1 === 'binary' || _ref1 === 'string') {
            _ref2 = options.rules.decorators;
            _results = [];
            for (decoratorName in _ref2) {
              decorator = _ref2[decoratorName];
              res = decorator.apply(null, parent[id]);
              if (isArray(res)) {
                mutations += 1;
                _results.push(parent[id] = res);
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }
      };
      recursive([mutable_tree], 0);
      if (options.debug) {
        return console.log("pass one");
      }
    };
    passOne();
    passTwo = function() {
      if (options.debug) {
        return console.log("pass two");
      }
    };
    passTwo();
    if (options.debug) {
      console.log("mutable_tree: " + (inspect(mutable_tree, false, 20, true)));
    }
    constant_tree_hook[2][0][3] = mutable_tree;
    work.new_ast = copy(constant_tree);
    if (options.debug) {
      console.log("new_ast: " + (inspect(work.new_ast, false, 20, true)));
    }
    console.log("done " + mutations + " mutations");
    if (options.debug) {
      console.log("generating code..");
    }
    work.new_src = pro.gen_code(work.new_ast, {
      beautify: options.pretty,
      indent_start: 0,
      indent_level: 4,
      quote_keys: false,
      space_colon: false
    });
    return options.onComplete(work.new_src);
  };

  exports.mutate = mutate = function(options) {
    if (options.debug) {
      console.log("mutate options: " + (inspect(options)));
    }
    return clone({
      src: options.obj[options.func].toString(),
      debug: options.debug,
      ratio: options.ratio,
      onComplete: function(new_src) {
        var newFunction;
        newFunction = eval(new_src);
        console.log("replaced function with " + newFunction);
        options.obj[options.func] = newFunction;
        return options.onComplete();
      }
    });
  };

  exports.readFile = readFile = function(opts) {
    var k, options, v;
    options = {
      file: '',
      encoding: 'utf-8',
      debug: false,
      ratio: 0.001,
      onError: function(err) {}
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    return fs.readFile(options.file, options.encoding, function(err, src) {
      if (err) {
        console.log("couldn't load file: " + err);
        async(function() {
          return options.onError(err);
        });
        return;
      }
      return clone({
        src: src,
        debug: options.debug,
        ratio: options.ratio,
        onComplete: function(new_src) {
          return options.onComplete(new_src);
        }
      });
    });
  };

  exports.mutable = mutable = function(f) {
    return f();
  };

  exports.cli = main = function() {
    var ratio;
    ratio = 0.001;
    if ((__indexOf.call(process.argv, '+') >= 0)) {
      ratio = 0.01;
    } else if ((__indexOf.call(process.argv, '++') >= 0)) {
      ratio = 0.05;
    } else if ((__indexOf.call(process.argv, '+++') >= 0)) {
      ratio = 0.10;
    } else if ((__indexOf.call(process.argv, '++++') >= 0)) {
      ratio = 0.20;
    } else if ((__indexOf.call(process.argv, '+++++') >= 0)) {
      ratio = 0.40;
    } else if ((__indexOf.call(process.argv, '++++++') >= 0)) {
      ratio = 0.60;
    } else if ((__indexOf.call(process.argv, '+++++++') >= 0)) {
      ratio = 0.80;
    } else if ((__indexOf.call(process.argv, '++++++++') >= 0)) {
      ratio = 0.90;
    }
    console.log("ratio: " + ratio);
    if (process.argv.length > 2) {
      return readFile({
        debug: (__indexOf.call(process.argv, 'debug') >= 0),
        pretty: (__indexOf.call(process.argv, 'pretty') >= 0),
        encoding: 'utf-8',
        file: process.argv[2],
        ratio: ratio,
        onError: function(err) {
          console.log("error: " + err);
          throw err;
        },
        onComplete: function(src) {
          return console.log(src);
        }
      });
    } else {
      return clone({
        src: fs.readFileSync('/dev/stdin').toString(),
        debug: (__indexOf.call(process.argv, 'debug') >= 0),
        pretty: (__indexOf.call(process.argv, 'pretty') >= 0),
        ratio: ratio,
        onError: function(err) {
          console.log("error: " + err);
          throw err;
        },
        onComplete: function(src) {
          return console.log(src);
        }
      });
    }
  };

}).call(this);
