// Generated by CoffeeScript 1.3.3
(function() {
  var P, async, clone, copy, deck, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, main, mutable, mutate, pro, readFile, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  fs = require('fs');

  inspect = require('util').inspect;

  async = require('ragtime').async;

  deck = require('deck');

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  exports.clone = clone = function(opts) {
    var i, item, items, k, mutateBranch, mutateTree, mutations, name, options, reservoir_ast, resolve, v, work, _i, _len;
    options = {
      src: "",
      ratio: 0.001,
      pretty: true,
      debug: false,
      ignore_var: false,
      context: function() {
        return [Math.cos, Math.sin, Math.random, Math.PI];
      },
      reservoir: {
        callables: [],
        constants: [],
        writables: []
      },
      clipboard: [],
      rules: {
        decorators: {}
      }
    };
    resolve = function(item) {
      var name, sub;
      name = "";
      if (item[0] === 'dot') {
        sub = "";
        if (isArray(item[1])) {
          sub = "" + resolve(item[1]);
        } else {
          sub = item[1][1];
        }
        name = "" + sub + "." + item[2];
      } else if (item[0] === 'name') {
        name = item[1];
      }
      return name;
    };
    items = [];
    try {
      reservoir_ast = jsp.parse("RESERVOIR = " + (options.context.toString()) + ";", {});
      items = reservoir_ast[1][0][1][3][3][0][1][1];
      console.log("imported context:");
    } catch (e) {
      console.log("couldn't run static analysis of context: " + e);
    }
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      name = resolve(item);
      i = void 0;
      try {
        i = eval(name);
      } catch (e) {
        console.log("error when checking " + name + ": " + e);
        continue;
      }
      if (isFunction(i)) {
        console.log(" - " + name + " is a function");
        options.reservoir.callables.push(name);
      } else if (isArray(i)) {
        console.log(" - " + name + " is an array - not supported yet");
      } else if (isNumber(i)) {
        console.log(" - " + name + " is a number");
        options.reservoir.constants.push(name);
      } else {
        console.log(" - type of " + name + " couldn't be found (value: " + i + ")");
      }
    }
    options.rules = {
      decorators: {
        multiply: function(type, value) {
          console.log("in multiply(" + type + "," + value + ")");
          if (type === 'num' && P(options.ratio * 1.0)) {
            console.log("multiplying..");
            return [type, Math.random() * value];
          }
        },
        add: function(type, value) {
          if (type === 'num' && P(options.ratio * 1.0)) {
            return [type, Math.random() + value];
          }
        },
        change_operator: function(type, operator, a, b) {
          var idx, operators;
          if (type === 'binary' && P(options.ratio * 1.0)) {
            if (options.debug) {
              console.log("change operator for " + type + ", " + operator + ", " + a + ", " + b);
            }
            operators = ['+', '-', '*', '/'];
            idx = operators.indexOf(operator);
            if (idx !== -1) {
              operators.splice(idx, 1);
            }
            return [type, deck.pick(operators), a, b];
          }
        },
        switch_terms: function(type, operator, a, b) {
          if (type === 'binary' && P(options.ratio * 1.0)) {
            if (options.debug) {
              console.log("switching terms for " + type + ", " + operator + ", " + a + ", " + b);
            }
            return [type, operator, b, a];
          }
        },
        delete_term: function(type, operator, a, b) {
          if (type === 'binary' && P(options.ratio * 0.0)) {
            if (options.debug) {
              console.log("deleting term for " + type + ", " + operator + ", " + a + ", " + b);
            }
            if (P(0.5)) {
              return a;
            } else {
              return b;
            }
          }
        },
        duplicate_term: function(type, operator, a, b) {
          var cpy;
          if (type === 'binary' && P(options.ratio * 0.0)) {
            if (options.debug) {
              console.log("duplicate_term for " + type + ", " + operator + ", " + a + ", " + b);
            }
            cpy = copy([type, operator, a, b]);
            if (P(0.5)) {
              return [type, operator, cpy, b];
            } else {
              return [type, operator, a, cpy];
            }
          }
        },
        change_read_variable: function(type, name, read_variables) {
          if (type === 'read_variable' && P(options.ratio * 1.0)) {
            return [type, deck.pick(options.reservoir.constants)];
          }
        },
        change_write_variable: function(type, x, output, input) {
          if (type === 'assign' && P(options.ratio * 1.0)) {
            console.log("changing assignment");
            return [type, x, deck.pick(options.reservoir.constants), input];
          }
        },
        copy_term: function(type, name, a, b) {
          var node;
          if (type === 'binary' && P(options.ratio * 1.0)) {
            node = copy([type, name, a, b]);
            if (options.debug) {
              console.log("copying " + (inspect(node)));
            }
            options.clipboard.push(node);
            return node;
          }
        },
        paste_replace: function(type, operator, a, b) {
          if (type === 'binary' && options.clipboard.length > 0) {
            options.clipboard[0];
            return options.clipboard.shift();
          }
        },
        paste_insert: function(type, operator, a, b) {
          var node, t;
          if (type === 'binary' && options.clipboard.length > 0) {
            node = options.clipboard[0];
            options.clipboard.shift();
            t = P(0.5) ? 2 : 3;
            node[t] = [type, operator, a, b];
            return node;
          }
        },
        mutate_string: function(type, value) {
          var c, c2, chars, new_chars, other_chars, r, _j, _len1;
          if (type === 'string' && P(options.ratio * 1.0)) {
            chars = value.split('');
            other_chars = "abcefghijklmnopqrstuvwxyz0123456789 ".split('');
            new_chars = [];
            r = function() {
              return chars[Math.round(Math.random() * other_chars.length)];
            };
            for (_j = 0, _len1 = chars.length; _j < _len1; _j++) {
              c = chars[_j];
              if (P(0.5)) {
                new_chars.push(c);
              } else {
                c2 = r();
                if (!isUndefined(c2)) {
                  new_chars.push(c2);
                }
              }
            }
            return ['string', new_chars.join('')];
          }
        }
      }
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    work = {};
    work.old_src = options.src;
    try {
      work.old_ast = jsp.parse("ENDPOINT = " + work.old_src + ";", {});
    } catch (e) {
      console.log(e.message);
    }
    work.context = options.context;
    mutations = [];
    mutateBranch = function(branch) {
      var analyze, branch_data, iterations, transform, _j, _results;
      branch_data = {
        callables: [],
        constants: [],
        writables: [],
        clipboard: []
      };
      analyze = function(parent, id) {
        var type, w, writable, _fn, _j, _k, _len1, _ref, _ref1;
        console.log("analyze(" + parent + "," + id + ")");
        console.log("checking: " + (inspect(parent[id], false, 20, true)));
        if (isArray(parent[id])) {
          console.log("is array. first try to apply decorators");
          type = parent[id][0];
          if (type === 'var') {
            _ref = parent[id][1];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              w = _ref[_j];
              writable = ['name', w];
              branch_data.writables.push(writable);
            }
          } else if (type === 'assign') {
            writable = copy(parent[id][2]);
            branch_data.writables.push(writable);
          }
          _fn = function(i) {
            return analyze(parent[id], i++);
          };
          for (i = _k = 0, _ref1 = parent[id].length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
            _fn(i);
          }
        }
        return analyze([branch], 0);
      };
      transform = function(parent, id) {
        var decorator, decoratorName, type, _fn, _j, _ref, _ref1, _results;
        console.log("recursive(" + parent + "," + id + ")\nchecking: " + (inspect(parent[id], false, 20, true)));
        if (isArray(parent[id])) {
          console.log("is array. first try to apply decorators");
          type = parent[id][0];
          if (type === 'num' || type === 'binary' || type === 'string' || type === 'assign') {
            console.log("applying rules");
            _ref = options.rules.decorators;
            _fn = function(decoratorName, decorator) {
              var res;
              res = decorator.apply(null, parent[id]);
              if (isArray(res)) {
                mutations += 1;
                return parent[id] = res;
              }
            };
            for (decoratorName in _ref) {
              decorator = _ref[decoratorName];
              _fn(decoratorName, decorator);
            }
          }
          console.log("then iterate over children recursively");
          _results = [];
          for (i = _j = 0, _ref1 = parent[id].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push((function(i) {
              return transform(parent[id], i++);
            })(i));
          }
          return _results;
        }
      };
      nb(iterations = 1);
      _results = [];
      for (i = _j = 0; 0 <= nb_iterations ? _j <= nb_iterations : _j >= nb_iterations; i = 0 <= nb_iterations ? ++_j : --_j) {
        console.log("ITERATION " + i);
        transform([branch], 0);
        _results.push(console.log("new branch: " + (inspect(branch, false, 20, true))));
      }
      return _results;
    };
    mutateTree = function(tree) {
      var branch, found, search;
      found = false;
      search = function(node) {
        var n, _j, _len1, _ref, _results;
        if (options.debug) {
          console.log("" + (inspect(node, false, 20, true)));
        }
        if (isArray(node)) {
          if (node[0] === 'call') {
            if ((_ref = "" + node[1]) === 'dot,name,evolve,mutable' || _ref === 'name,mutable') {
              found = true;
              return node[2][0][3] = mutateBranch(copy(node[2][0][3]));
            }
          } else {
            _results = [];
            for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
              n = node[_j];
              _results.push(search(n));
            }
            return _results;
          }
        }
      };
      search(tree);
      if (!found) {
        branch = [];
        try {
          branch = copy(tree[1][0][1][3][3]);
        } catch (e) {
          console.log("couldn't find first function, aborting: " + e);
        }
        if (branch.length > 0) {
          console.log("found function! mutating it..");
          tree[1][0][1][3][3] = mutateBranch(branch);
        }
      }
      return tree;
    };
    work.new_ast = mutateTree(copy(work.old_tree));
    console.log("new_ast: " + (inspect(work.new_ast, false, 20, true)));
    console.log("done " + mutations + " mutations");
    if (options.debug) {
      console.log("generating code..");
    }
    work.new_src = pro.gen_code(work.new_ast, {
      beautify: options.pretty,
      indent_start: 0,
      indent_level: 4,
      quote_keys: false,
      space_colon: false
    });
    return options.onComplete(work.new_src);
  };

  exports.mutate = mutate = function(options) {
    if (options.debug) {
      console.log("mutate options: " + (inspect(options)));
    }
    return clone({
      src: options.obj[options.func].toString(),
      debug: options.debug,
      ratio: options.ratio,
      onComplete: function(new_src) {
        var newFunction;
        newFunction = eval(new_src);
        console.log("replaced function with " + newFunction);
        options.obj[options.func] = newFunction;
        return options.onComplete();
      }
    });
  };

  exports.readFile = readFile = function(opts) {
    var k, options, v;
    options = {
      file: '',
      encoding: 'utf-8',
      debug: false,
      ratio: 0.001,
      onError: function(err) {}
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    return fs.readFile(options.file, options.encoding, function(err, src) {
      if (err) {
        console.log("couldn't load file: " + err);
        async(function() {
          return options.onError(err);
        });
        return;
      }
      return clone({
        src: src,
        debug: options.debug,
        ratio: options.ratio,
        onComplete: function(new_src) {
          return options.onComplete(new_src);
        }
      });
    });
  };

  exports.mutable = mutable = function(f) {
    return f();
  };

  exports.cli = main = function() {
    var ratio;
    ratio = 0.001;
    if ((__indexOf.call(process.argv, '+') >= 0)) {
      ratio = 0.01;
    } else if ((__indexOf.call(process.argv, '++') >= 0)) {
      ratio = 0.05;
    } else if ((__indexOf.call(process.argv, '+++') >= 0)) {
      ratio = 0.10;
    } else if ((__indexOf.call(process.argv, '++++') >= 0)) {
      ratio = 0.20;
    } else if ((__indexOf.call(process.argv, '+++++') >= 0)) {
      ratio = 0.40;
    } else if ((__indexOf.call(process.argv, '++++++') >= 0)) {
      ratio = 0.60;
    } else if ((__indexOf.call(process.argv, '+++++++') >= 0)) {
      ratio = 0.80;
    } else if ((__indexOf.call(process.argv, '++++++++') >= 0)) {
      ratio = 0.90;
    }
    console.log("ratio: " + ratio);
    if (process.argv.length > 2) {
      return readFile({
        debug: (__indexOf.call(process.argv, 'debug') >= 0),
        pretty: (__indexOf.call(process.argv, 'pretty') >= 0),
        encoding: 'utf-8',
        file: process.argv[2],
        ratio: ratio,
        onError: function(err) {
          console.log("error: " + err);
          throw err;
        },
        onComplete: function(src) {
          return console.log(src);
        }
      });
    } else {
      return clone({
        src: fs.readFileSync('/dev/stdin').toString(),
        debug: (__indexOf.call(process.argv, 'debug') >= 0),
        pretty: (__indexOf.call(process.argv, 'pretty') >= 0),
        ratio: ratio,
        onError: function(err) {
          console.log("error: " + err);
          throw err;
        },
        onComplete: function(src) {
          return console.log(src);
        }
      });
    }
  };

}).call(this);
