// Generated by CoffeeScript 1.3.3
(function() {
  var P, THIS_CODE_CAN_BE_MUTATED_TOO, async, callable_functions, callable_functions_ast, callable_variables, clone, code_to_ast, deck, fidelity, fs, getNodes, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, jsp, k, main, mutate, optimize_ast, options, pro, v, writable_functions, writable_variables,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  fs = require('fs');

  inspect = require('util').inspect;

  async = require('ragtime').async;

  deck = require('deck');

  /*
  TODO substitute numbers, variables, called functions.. by
  themselves
  also: delete them, or duplicate them
  or add a random new one
  */


  clone = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  options = {};

  code_to_ast = function(code) {
    return function(cb) {
      return async(function() {
        return cb(jsp.parse(code, options.strict_semicolons));
      });
    };
  };

  optimize_ast = function(ast) {
    return function(cb) {
      return async(function() {
        ast = pro.ast_mangle(ast, options.mangle_options);
        return async(function() {
          ast = pro.ast_squeeze(ast, options.squeeze_options);
          return async(function() {
            return cb(ast);
          });
        });
      });
    };
  };

  getNodes = function(root) {
    var nodes, parse;
    nodes = [];
    parse = function(list) {
      var item, _i, _j, _len, _len1, _results;
      if (isArray(list)) {
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          item = list[_i];
          nodes.push(item);
        }
        _results = [];
        for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
          item = list[_j];
          if (isArray) {
            _results.push(parse(item));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
    parse(root);
    return {
      nodes: nodes
    };
  };

  callable_variables = {
    x1: 10,
    x2: 10,
    x3: 10,
    x4: 10,
    x5: 10
  };

  writable_variables = {
    x1: 10,
    x2: 10,
    x3: 10,
    x4: 10,
    x5: 10
  };

  writable_functions = {
    f1: 10,
    f2: 10,
    f3: 10,
    f4: 10,
    f5: 10
  };

  callable_functions_ast = {
    f1: ['name', 'f1'],
    f2: ['name', 'f2'],
    f3: ['name', 'f3'],
    f4: ['name', 'f4'],
    f5: ['name', 'f5'],
    'Math.cos': ['dot', ['name', 'Math'], 'cos'],
    'Math.sin': ['dot', ['name', 'Math'], 'sin']
  };

  callable_functions = {};

  for (k in callable_functions_ast) {
    v = callable_functions_ast[k];
    callable_functions[k] = 10;
  }

  fidelity = 0.95;

  THIS_CODE_CAN_BE_MUTATED_TOO = {
    mutateNumber: function(value) {
      var action, numOperations;
      if (P(fidelity)) {
        return value;
      }
      numOperations = {
        mult: 5000
      };
      action = deck.pick(numOperations);
      console.log("action: " + action);
      switch (action) {
        case 'mult':
          console.log("MUTATION: NUMBER " + value + " * Math.random()");
          return value * Math.random();
      }
      return value;
    },
    substituteValueNode: function(value, values) {
      var ast;
      if (P(fidelity)) {
        return value;
      } else {
        ast = deck.pick(values);
        if (isUndefined(ast)) {
          return value;
        } else {
          return ast;
        }
      }
    },
    substituteCallableFunctionAST: function(value) {
      var f;
      if (P(fidelity)) {
        return value;
      } else {
        f = deck.pick(callable_functions);
        return callable_functions_ast[f];
      }
    },
    substituteCallableFunctionName: function(value) {
      if (P(fidelity)) {
        return value;
      } else {
        return deck.pick(callable_functions);
      }
    },
    substituteWritableFunctionName: function(value) {
      if (P(fidelity)) {
        return value;
      } else {
        return ['name', deck.pick(writable_functions)];
      }
    },
    substituteWritableVariableName: function(value) {
      var varName;
      if (P(fidelity)) {
        return value;
      } else {
        varName = deck.pick(writable_variables);
        if (varName !== void 0) {
          return ['name', varName];
        }
        return value;
      }
    },
    substituteCallableVariableName: function(value) {
      if (P(fidelity)) {
        return value;
      } else {
        return ['name', deck.pick(callable_variables)];
      }
    },
    substituteBinaryOperator: function(value) {
      var operators;
      if (P(fidelity)) {
        return value;
      } else {
        operators = {
          '+': 100,
          '/': 50,
          '-': 100,
          '*': 150,
          '^': 5
        };
        return deck.pick(operators);
      }
    }
  };

  mutate = function(old_code, tmin, tmax, dbg, cb) {
    return async(function() {
      var algo, copy, header, i, new_ast, new_code, node, nodes, old_ast, transform, values, _i, _j, _k, _len, _ref, _ref1;
      copy = [];
      old_ast = jsp.parse(old_code, options.strict_semicolons);
      if (dbg) {
        console.log("old: " + (inspect(old_ast, false, 20, true)));
      }
      nodes = getNodes(old_ast).nodes;
      values = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        console.log("testing node: " + node);
        if (isArray(node)) {
          if ((_ref = node[0]) === 'call' || _ref === 'name' || _ref === 'num') {
            if (node[0] === 'name') {
              if (_ref1 = node[1], __indexOf.call(callable_variables, _ref1) < 0) {
                continue;
              }
            }
            k = "" + node[0];
            values.push(node);
          }
        }
      }
      algo = THIS_CODE_CAN_BE_MUTATED_TOO;
      transform = function(node, n0) {
        var i, nodeType, r, varName, _j, _ref2;
        if (n0 == null) {
          n0 = '';
        }
        if (isArray(node)) {
          if (node.length === 0) {
            return node;
          }
          nodeType = node[0];
          if (node.length === 1) {
            node[0] = transform(node[0], '');
          }
          if (nodeType === 'var') {
            return node;
          }
          if (nodeType === 'assign') {
            varName = node[2][1];
            if (varName in writable_variables) {
              node[2] = algo.substituteWritableVariableName(node[2]);
            } else if (varName in writable_functions) {
              node[2] = algo.substituteWritableFunctionName(node[2]);
            }
          }
          if (nodeType === 'binary') {
            node[1] = algo.substituteBinaryOperator(node[1]);
            node[2] = algo.substituteValueNode(node[2], values);
            node[3] = algo.substituteValueNode(node[3], values);
          }
          if (nodeType === 'num') {
            node[1] = algo.mutateNumber(node[1]);
          }
          if (nodeType === 'call') {
            varName = node[1][1];
            if (varName in callable_variables) {
              node[1] = algo.substituteCallableVariableName(node[1]);
            } else if (varName in callable_functions) {
              node[1] = algo.substituteCallableFunctionAST(node[1]);
            }
          }
          for (i = _j = 1, _ref2 = node.length; 1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 1 <= _ref2 ? ++_j : --_j) {
            if (isArray(node[i])) {
              r = transform(node[i], nodeType);
              if (r !== void 0) {
                node[i] = r;
              }
            }
          }
        }
        return node;
      };
      new_ast = transform(old_ast);
      if (dbg) {
        console.log("copy: " + (inspect(new_ast, false, 20, true)));
      }
      try {
        new_code = pro.gen_code(new_ast, options.gen_options);
        header = "////////// MEMORY ////////// \nvar x0=0";
        for (i = _j = 1; _j <= 6; i = ++_j) {
          header += ", x" + i + "=0";
        }
        header += ";\n";
        for (i = _k = 1; _k <= 6; i = ++_k) {
          header += "var f" + i + "=function(){ return 0; };\n";
        }
        new_code = "" + header + " /////// END OF MEMORY ////////\n\n " + new_code;
        console.log("success after " + tmin + " tentatives");
        return async(function() {
          return cb(new_code);
        });
      } catch (e) {
        if (tmin < tmax) {
          return async(function() {
            return mutate(old_code, tmin + 1, tmax, dbg, cb);
          });
        } else {
          console.log("aborting after " + tmin + " tentatives");
          return async(function() {
            return cb(old_code);
          });
        }
      }
    });
  };

  main = function() {
    var dbg, filePath, insist;
    filePath = process.argv[2];
    dbg = (__indexOf.call(process.argv, 'debug') >= 0);
    insist = (__indexOf.call(process.argv, 'insist') >= 0);
    if (!filePath) {
      console.log("error, no file");
      return;
    }
    return fs.readFile(filePath, 'utf-8', function(err, old_code) {
      var tentatives;
      if (err) {
        throw err;
        return;
      }
      if (dbg) {
        console.log(old_code);
      }
      tentatives = 1;
      if (insist) {
        tentatives = 3;
      }
      return mutate(old_code, 0, tentatives, dbg, function(new_code) {
        return console.log("" + new_code);
      });
    });
  };

  exports.cli = main;

}).call(this);
