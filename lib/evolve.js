// Generated by CoffeeScript 1.4.0
(function() {
  var P, async, clone, copy, cs2js, deck, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, js2cs, jsp, main, makeRules, mutable, mutate, pro, readFile, toAST,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  jsp = require("../node_modules/uglify-js/lib/parse-js");

  pro = require("../node_modules/uglify-js/lib/process");

  cs2js = require('../node_modules/coffee-script').compile;

  js2cs = require('../node_modules/js2coffee/lib/js2coffee').build;

  fs = require('fs');

  inspect = require('util').inspect;

  async = require('ragtime').async;

  deck = require('deck');

  makeRules = require('./rules').makeRules;

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.toAST = toAST = function(f) {
    return jsp.parse(f.toString());
  };

  exports.clone = clone = function(opts) {
    var globals, i, item, items, k, mutateBranch, mutateTree, mutations, name, options, reservoir_ast, resolve, v, work, _i, _len;
    options = {
      src: "",
      ratio: 0.01,
      iterations: 2,
      pretty: true,
      debug: false,
      ignore_var: false,
      isCoffee: false,
      context: function() {
        return [Math.abs, Math.acos, Math.asin, Math.atan, Math.atan2, Math.ceil, Math.cos, Math.exp, Math.floor, Math.log, Math.max, Math.min, Math.pow, Math.random, Math.round, Math.sin, Math.sqrt, Math.tan, Math.PI];
      }
    };
    globals = {
      callables: [],
      readables: [],
      writables: []
    };
    mutations = 0;
    resolve = function(item) {
      var name, sub;
      name = "";
      if (item[0] === 'dot') {
        sub = "";
        if (isArray(item[1])) {
          sub = "" + resolve(item[1]);
        } else {
          sub = item[1][1];
        }
        name = "" + sub + "." + item[2];
      } else if (item[0] === 'name') {
        name = item[1];
      }
      return name;
    };
    items = [];
    try {
      reservoir_ast = jsp.parse("RESERVOIR = " + (options.context.toString()) + ";", {});
      items = reservoir_ast[1][0][1][3][3][0][1][1];
      if (options.debug) {
        console.log("imported context:");
      }
    } catch (e) {
      console.log("couldn't run static analysis of context: " + e);
    }
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      name = resolve(item);
      i = void 0;
      try {
        i = eval(name);
      } catch (e) {
        console.log("error when checking " + name + ": " + e);
        continue;
      }
      if (isFunction(i)) {
        if (options.debug) {
          console.log(" - " + name + " is a function");
        }
        globals.callables.push(name);
      } else if (isArray(i)) {
        if (options.debug) {
          console.log(" - " + name + " is an array - not supported yet");
        }
      } else if (isNumber(i)) {
        if (options.debug) {
          console.log(" - " + name + " is a number");
        }
        globals.readables.push(name);
      } else {
        if (options.debug) {
          console.log(" - type of " + name + " couldn't be found (value: " + i + ")");
        }
      }
    }
    for (k in opts) {
      v = opts[k];
      if (k !== 'rules') {
        options[k] = v;
      }
    }
    work = {};
    work.old_src = options.src;
    if (options.debug) {
      console.log("old_src: " + work.old_src);
    }
    if (options.isCoffee) {
      work.old_src = cs2js(work.old_src, {
        bare: true
      });
      if (options.debug) {
        console.log("old_src: " + work.old_src);
      }
    }
    try {
      work.old_ast = jsp.parse(work.old_src, {});
    } catch (e1) {
      if (e1.message === 'Unexpected token: punc (()') {
        try {
          work.old_ast = jsp.parse("var ROOT = " + work.old_src + ";", {});
          work.old_ast[1][0] = work.old_ast[1][0][1][0][1];
        } catch (e2) {
          console.log(e2.message);
          console.log("function wrapping failed: " + e1.message);
          return;
        }
      } else {
        console.log("unsupported parsing error: " + e1.message);
      }
    }
    mutateBranch = function(branch) {
      var analyze, clipboard, locals, rules, transform, _j, _ref;
      locals = {
        callables: [],
        readables: [],
        writables: []
      };
      clipboard = [];
      analyze = function(parent, id) {
        var type, w, writable, _fn, _j, _k, _len1, _ref, _ref1;
        if (isArray(parent[id])) {
          type = parent[id][0];
          if (type === 'var') {
            _ref = parent[id][1];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              w = _ref[_j];
              writable = ['name', w];
              locals.writables.push(writable);
            }
          } else if (type === 'assign') {
            writable = copy(parent[id][2]);
            locals.writables.push(writable);
          }
          _fn = function(i) {
            return analyze(parent[id], i++);
          };
          for (i = _k = 0, _ref1 = parent[id].length; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
            _fn(i);
          }
        }
        return analyze([branch], 0);
      };
      rules = makeRules(options, globals, locals, clipboard);
      transform = function(parent, id) {
        var res, rule, type, _j, _ref, _results;
        if (isArray(parent[id])) {
          type = parent[id][0];
          for (name in rules) {
            rule = rules[name];
            res = rule.apply(null, parent[id]);
            if (isArray(res)) {
              mutations += 1;
              parent[id] = res;
            }
          }
          _results = [];
          for (i = _j = 0, _ref = parent[id].length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
            _results.push(transform(parent[id], i++));
          }
          return _results;
        }
      };
      for (i = _j = 0, _ref = options.iterations; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
        if (options.debug) {
          console.log("ITERATION " + i);
        }
        transform([branch], 0);
        if (options.debug) {
          console.log("new branch: " + (inspect(branch, false, 20, true)));
        }
      }
      return branch;
    };
    mutateTree = function(tree) {
      var branch, found, search;
      found = false;
      search = function(node) {
        var n, _j, _len1, _ref, _results;
        if (isArray(node)) {
          if (node[0] === 'call') {
            if ((_ref = "" + node[1]) === 'dot,name,evolve,mutable' || _ref === 'name,mutable') {
              found = true;
              return node[2][0][3] = mutateBranch(copy(node[2][0][3]));
            }
          } else {
            _results = [];
            for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
              n = node[_j];
              _results.push(search(n));
            }
            return _results;
          }
        }
      };
      search(tree);
      if (!found) {
        branch = void 0;
        try {
          branch = tree;
        } catch (e) {
          if (options.debug) {
            console.log("couldn't find first function, aborting: " + e);
          }
        }
        if (branch) {
          if (options.debug) {
            console.log("found function! mutating it..");
          }
          tree = mutateBranch(copy(branch));
        } else {
          if (options.debug) {
            console.log("could not find branch");
          }
        }
      }
      return tree;
    };
    if (options.debug) {
      console.log("old AST: " + (inspect(work.old_ast, false, 20, true)) + "\n\n\n\n");
    }
    work.new_ast = mutateTree(copy(work.old_ast));
    if (options.isCoffee) {
      try {
        if (work.new_ast[1][0][0] === 'var') {
          work.new_ast[1].shift();
        }
      } catch (e) {
        if (options.debug) {
          console.log("no var? good thing? " + e);
        }
      }
    }
    if (options.debug) {
      console.log("new AST: " + (inspect(work.new_ast, false, 20, true)));
    }
    if (options.debug) {
      console.log("applied " + mutations + " mutations. generating code..");
    }
    work.new_src = pro.gen_code(work.new_ast, {
      beautify: options.pretty,
      indent_start: 0,
      indent_level: 4,
      quote_keys: false,
      space_colon: false
    });
    if (options.isCoffee) {
      work.new_src = js2cs(work.new_src, {
        no_comments: false
      });
    }
    return options.onComplete(work.new_src);
  };

  exports.mutate = mutate = function(obj, func, options) {
    var _ref, _ref1, _ref2, _ref3;
    if (options == null) {
      options = {};
    }
    return clone({
      src: obj[func].toString(),
      isCoffee: (_ref = options.isCoffee) != null ? _ref : false,
      debug: (_ref1 = options.debug) != null ? _ref1 : false,
      ratio: (_ref2 = options.ratio) != null ? _ref2 : 0.01,
      iterations: (_ref3 = options.iterations) != null ? _ref3 : 2,
      onComplete: function(new_src) {
        var newFunction;
        newFunction = eval(new_src);
        if (options.debug) {
          console.log("replaced function with " + newFunction);
        }
        obj[func] = newFunction;
        return options.onComplete();
      }
    });
  };

  exports.readFile = readFile = function(opts) {
    var k, options, v;
    options = {
      file: '',
      encoding: 'utf-8',
      debug: false,
      ratio: 0.01,
      iterations: 1,
      onError: function(err) {}
    };
    for (k in opts) {
      v = opts[k];
      options[k] = v;
    }
    return fs.readFile(options.file, options.encoding, function(err, src) {
      var isCoffee;
      if (err) {
        console.log("couldn't load file: " + err);
        async(function() {
          return options.onError(err);
        });
        return;
      }
      isCoffee = options.file.slice(-7) === ".coffee";
      return clone({
        src: src,
        isCoffee: isCoffee,
        debug: options.debug,
        ratio: options.ratio,
        iterations: options.iterations,
        onComplete: function(new_src) {
          return options.onComplete(new_src);
        }
      });
    });
  };

  exports.mutable = mutable = function(f) {
    return f();
  };

  exports.cli = main = function() {
    var a, args, config, debug, encoding, file, iterations, nb_args, pretty, ratio, _i, _len;
    args = process.argv;
    nb_args = args.length;
    file = args[2];
    debug = __indexOf.call(args, 'debug') >= 0;
    pretty = __indexOf.call(args, 'pretty') >= 0;
    encoding = 'utf-8';
    ratio = 0.10;
    iterations = 1;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (a.lastIndexOf('ratio=', 0) === 0) {
        ratio = Number(a.slice(6));
      }
    }
    config = {
      debug: debug,
      pretty: pretty,
      encoding: encoding,
      ratio: ratio,
      iterations: iterations
    };
    config.onComplete = function(src) {
      return console.log(src);
    };
    config.onError = function(err) {
      console.log("error: " + err);
      return process.exit(-1);
    };
    if (nb_args > 2) {
      config.file = file;
      return readFile(config);
    } else {
      config.src = fs.readFileSync('/dev/stdin').toString();
      return clone(config);
    }
  };

}).call(this);
