// Generated by CoffeeScript 1.6.3
(function() {
  var P, copy, deck, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, makeRules;

  inspect = require('util').inspect;

  deck = require('deck');

  copy = function(a) {
    return JSON.parse(JSON.stringify(a));
  };

  P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  exports.makeRules = makeRules = function(options, globals, locals, clipboard) {
    var callables, operators, other_chars, p, ratio, readables, writables;
    ratio = options.ratio;
    callables = globals.callables.concat(locals.callables);
    writables = globals.writables.concat(locals.writables);
    readables = globals.readables.concat(locals.readables);
    operators = ['+', '-', '*', '/'];
    other_chars = "abcefghijklmnopqrstuvwxyz0123456789 ".split('');
    p = {
      multiply: function() {
        return P(ratio);
      },
      add: function() {
        return P(ratio);
      },
      opchange: function() {
        return P(ratio);
      },
      termswitch: function() {
        return P(ratio);
      },
      termdelete: function() {
        return P(0.0);
      },
      termduplic: function() {
        return P(0.0);
      },
      termcopy: function() {
        return P(0.0);
      },
      termpaste: function() {
        return P(0.5);
      },
      strmutate: function() {
        return P(ratio);
      }
    };
    return {
      multiply: function(t, x) {
        if (t === 'num' && p.multiply()) {
          return [t, Math.random() * x];
        }
      },
      add: function(t, x) {
        if (t === 'num' && p.add()) {
          return [t, Math.random() + x];
        }
      },
      opchange: function(t, o, a, b) {
        var idx, ops;
        if (t === 'binary' && p.opchange()) {
          ops = copy(operators);
          idx = ops.indexOf(o);
          if (idx !== -1) {
            ops.splice(idx, 1);
          }
          return [t, deck.pick(ops), a, b];
        }
      },
      termswitch: function(t, o, a, b) {
        if (t === 'binary' && p.termswitch()) {
          return [t, o, b, a];
        }
      },
      termdelete: function(t, o, a, b) {
        if (t === 'binary' && p.termdelete()) {
          if (P(0.5)) {
            return a;
          } else {
            return b;
          }
        }
      },
      termduplic: function(t, o, a, b) {
        var cpy;
        if (t === 'binary' && p.termduplic()) {
          cpy = copy([t, o, a, b]);
          if (P(0.5)) {
            return [t, o, cpy, b];
          } else {
            return [t, o, a, cpy];
          }
        }
      },
      termcopy: function(t, name, a, b) {
        var node;
        if (t === 'binary' && p.termcopy()) {
          node = copy([t, name, a, b]);
          clipboard.push(node);
          return node;
        }
      },
      termpaste: function(t, o, a, b) {
        var node, r;
        if (t === 'binary' && clipboard.length > 0) {
          node = clipboard[0];
          clipboard.shift();
          if (p.termpaste()) {
            r = P(0.5) ? 2 : 3;
            node[r] = [t, o, a, b];
          }
          return node;
        }
      },
      strmutate: function(t, s) {
        var c, c2, chars, new_chars, r, _i, _len;
        if (t === 'string' && p.strmutate()) {
          chars = s.split('');
          new_chars = [];
          r = function() {
            return chars[Math.round(Math.random() * other_chars.length)];
          };
          for (_i = 0, _len = chars.length; _i < _len; _i++) {
            c = chars[_i];
            if (P(0.5)) {
              new_chars.push(c);
            } else {
              c2 = r();
              if (!isUndefined(c2)) {
                new_chars.push(c2);
              }
            }
          }
          return ['string', new_chars.join('')];
        }
      }
    };
  };

}).call(this);
