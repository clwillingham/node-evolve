{"google":"UA-35909229-1","name":"node-evolve","tagline":"library for evolving source code","body":"node-evolve\r\n===========\r\n\r\nlibrary for evolving source code\r\n\r\n## Summary\r\n\r\nEvolve is a library designed to explore parameters, algorithms and solutions automatically,\r\nby introducing random changes in a program.\r\n\r\nIt works by mutating specific (or whole) parts of your code JavaScript ASTs, \r\nidentified using a magic function:\r\n\r\n```CoffeeScript\r\nmutable       value\r\nmutable ->    statements\r\nmutable -> -> function\r\n```\r\n\r\nThen a second function, \"mutate()\", will read your code (either statically, as a file, or dynamically, \r\nin the running process), and apply some mutations on it.\r\n\r\nTheses mutations are probabilistic (you can adjust the mutation factor, and in the future, the mutation rules), \r\nand may modify the AST structure, statements, assignements, function calls, values and operations.\r\n\r\nNode-evolve use a constraint system for early detection of impossible mutations, so\r\nit should produce interesting results (?) most of the time.\r\n\r\nSince there is absolutely no guarantee that your program will still work, or even \"evaluate\"\r\nafter mutation, you should use a higher-level library to manage individuals, population,\r\nfitness and selection.\r\n\r\n## Examples\r\n\r\n### Self-replicating program\r\n\r\n    $ coffee examples/demos/bacteria/bacteria.coffee\r\n\r\n Will run a minimalist demo program which can replicates itself (it just print a modified\r\n version of its own source code to the standard output).\r\nTo keep the demo simple, it is constrained to mutate only one thing - its own mutation rate:\r\n\r\n```CoffeeScript\r\nevolve = require('evolve')\r\nmutation_rate = 0.001\r\nfoo = .20\r\nevolve.mutable ->\r\n  foo = foo * 0.10\r\n  mutation_rate = Math.cos(0.001) + Math.sin(0.5)\r\n  mutation_rate = mutation_rate / foo\r\nevolve.readFile\r\n  ratio: mutation_rate\r\n  file: process.argv[1]\r\n  debug: false\r\n  onComplete: (src) ->\r\n    console.log src\r\n```\r\n\r\n### \"Machine\" code generation\r\n\r\nThis is still experimental (and not fully working), but thanks to node-cello\r\nit is easy to create \"mutable templates\" to generate parts, or complete programs\r\nin C language, and similar (eg. OpenCL kernels, for genetic GPGPU programming).\r\n\r\nSee the dedicated [examples](https://github.com/daizoru/node-evolve/tree/master/examples/templates \"example\")  folder.\r\n\r\n### More examples\r\n\r\nPlease browse the [examples](https://github.com/daizoru/node-evolve/tree/master/examples \"examples\") for a comprehensive tour of features and possible use cases.\r\n\r\n## WARNING\r\n\r\n  node-evolve is still in development and won't solve all problems for you:\r\n  no matter how powerful it might looks like, you still have to design your program - and model your problem - carefully.\r\n\r\n## Installation\r\n\r\n  To install it as a dependency of your program, just type:\r\n\r\n    $ npm install evolve\r\n\r\n  To install it globally, and benefit from the *evolve* commandline script, do:\r\n\r\n    $ npm install -g evolve\r\n\r\n\r\n## Introduction / Overview / features \r\n\r\n### Built-in mutation rules\r\n\r\nVarious mutations are already available in node-evolve:\r\nrandom insert, replace, delete of AST nodes, numbers, strings..\r\n\r\n### Constrained syntax and semantics\r\n\r\nnode-evolve will try hard to avoid useless or bad mutations - your code will already have a hard time surviving its first eval() anyway!\r\n\r\nIt works thanks to AST constraints.\r\nThese constraints prevent mutating this:\r\n\r\n```JavaScript\r\nvar x = 4 + 2 / y;\r\n```\r\n\r\nTo this:\r\n\r\n```JavaScript\r\nvar 3 = * 4 + 2 + y /;\r\n```\r\n\r\nBecause it would violates three constraints (assign to a number,\r\nlone '/' and '*' operators..)\r\n\r\nBut for instance, this mutation would be allowed: \r\n\r\n```JavaScript\r\nvar y = 2 / x / y + 4 ;\r\n```\r\n\r\nIn the end, all these constraints make mutation more efficient,\r\nby avoiding running a \"compilation\" step or evaluation on obviously bad code. It saves time.\r\n\r\n### Customizable rules\r\n\r\nYou can input your own rules, if they can be applied to an AST node (or the root node of the whole tree).\r\n\r\n### Simple type checking\r\n\r\nnode-evolve check that incompatible references are not mixed.\r\n\r\nFor instance, if you define this context:\r\n\r\n```CoffeeScript\r\ncontext = -> [ Math.PI, Math.cos ]\r\n```\r\n\r\nthen this mutation can't happen with node-evolve:\r\n\r\n```CoffeeScript\r\nvar x = Math.PI * Math.cos;\r\n```\r\n\r\nBut this one can:\r\n\r\n```CoffeeScript\r\nvar x = Math.PI * Math.cos(Math.PI);\r\n```\r\n\r\nOn the other hand, this one is prohibited:\r\n\r\n```CoffeeScript\r\nMath.PI = x * Math.cos(x);\r\n```\r\n\r\nSince variables and functions passed in context are read-only\r\n\r\n\r\n\r\n## Documentation\r\n\r\n### Best practices\r\n\r\n  You can combine markers (annotation functions) with mutation of genetic rules,\r\n  to mutate the mutation process itself. The idea is, if you wrap your functions f and g\r\n  with \"do-nothing\" functions like a and b:\r\n\r\n  ```JavaScript\r\n  a(f(b(g(42))))\r\n  ```\r\n\r\n  The mutation may use this information (that there is a a and a b) to\r\n  change mutations rules accordingly.\r\n  Actually, a and b may do things - it's just that it is also convenient\r\n  if they does nothing, to simply wrap and \"mark\" parts of the code.\r\n\r\n  With this technique, evolution can optimize it's own fork/mutation process,\r\n  and converge faster to a result.\r\n  \r\n  See a work-in-progress example [here](https://github.com/daizoru/node-evolve/tree/master/examples/demos/mutations \"here\").\r\n\r\n### List of supported mutations\r\n\r\n#### Numerical values\r\n\r\n  Numerical values are subject to mutation, like random multiplication or addition.\r\n\r\n#### Binary operator substitution\r\n\r\n  Operator of binary operations may be substituted by any operator\r\n  of this list: + - * /\r\n\r\n#### Binary operator switching\r\n\r\n  This mutation simply switch two terms of an operation,\r\n  eg. 10.0 / 5.0 becomes 5.0 / 10.0. \r\n\r\n#### EXPERIMENTAL - String mutation, levenshtyle.\r\n\r\n  String mutation is supported, and done using atomic operators like add, delete, move and substitution. However it is still experimental, and doesn't offer\r\n  much control over which ASCII characters are allowed, forbidden,\r\n  constants strings, collections of strings.. you have to implement this\r\n  yourself for the moment (using Rules)\r\n\r\n#### EXPERIMENTAL - Block copying, cutting & pasting\r\n\r\n  This mutation copy or cut a node of the AST tree to another place.\r\n  It may replace a node or insert between two.\r\n\r\n#### EXPERIMENTAL - Variable substitution\r\n\r\n  Any variable is subject to change and remplacement by another variable.\r\n\r\n#### EXPERIMENTAL - Support for multiples iterations\r\n \r\nIt can apply more than one layer of mutation:\r\nFor instance, one iteration might copy AST nodes to a buffer,\r\nand another may paste the content to overwrite or insert data.\r\n\r\nUse this feature to create complex, combined mutations.\r\n\r\n## How-to\r\n\r\n### Use it in command line\r\n\r\n    $ evolve src [ratio=0.42] [debug]\r\n\r\nExample :\r\n\r\n    $ evolve examples/basic/with_mutable.js ratio=0.10\r\n\r\n```JavaScript\r\nmutable(function() {\r\n    a = x * 1;\r\n    b = y * 1;\r\n    z = \"hello\";\r\n    return c = 1.4881885522045195 * z;\r\n});\r\n```\r\n\r\n### Using the API\r\n\r\n#### Defining a mutable value\r\n\r\n```CoffeeScript\r\n{mutable} = require 'evolve'\r\n\r\n# x is now a mutable: it's definition may by readable and evolvable\r\n# using node-evolve parser\r\nx = mutable Math.round Math.sqrt Math.PI * Math.PI / 2\r\n```\r\n\r\n```CoffeeScript\r\n{mutable} = require 'evolve'\r\n\r\nclass Foo\r\n\r\n  constructor: ->\r\n  \r\n  foo: (x,y,z) =>\r\n\r\n    [a,b,c] = [0,0,0]\r\n\r\n    # define a block of evolvable code, algorithm, neural network..\r\n    mutable ->\r\n\r\n      # the evolved code can only mess with foo()'s variables\r\n      # if evolution goes wrong\r\n      a = x * 1\r\n      b = y * 1\r\n      c = z * 1\r\n\r\n      # you can add an \"hidden\" level of memory\r\n      f = 5\r\n      g = 42 \r\n\r\n      # and maths!\r\n      b = Math.cos(f) + Math.cos(g * a)\r\n      c = a + 3\r\n\r\n    # outside the block, you can call your stuff as usual\r\n    @bar a, b, c\r\n\r\n```\r\n\r\n#### Defining a mutable function\r\n\r\n```CoffeeScript\r\nevolve = require 'evolve'\r\n\r\nclass Foo\r\n\r\n  constructor: ->\r\n  \r\n  foo: (x,y,z) =>\r\n\r\n    [a,b,c] = [0,0,0]\r\n\r\n    # define a block of evolvable code, algorithm, neural network..\r\n    func = evolve.mutable -> ->\r\n\r\n      # the evolved code can only mess with foo()'s variables\r\n      # if evolution goes wrong\r\n      a = x * 1\r\n      b = y * 1\r\n      c = z * 1\r\n\r\n      # you can add an \"hidden\" level of memory\r\n      f = 5\r\n      g = 42 \r\n\r\n      # and maths!\r\n      b = Math.cos(f) + Math.cos(g * a)\r\n      c = a + 3\r\n\r\n    func()\r\n\r\n    # outside the block, you can call your stuff as usual\r\n    @bar a, b, c\r\n\r\n```\r\n\r\n#### Dynamic mutation of the currently running program (CoffeeScript example)\r\n\r\n```CoffeeScript\r\n{mutate} = require 'evolve'\r\n\r\nevolve.mutate \r\n  obj: Foo.prototype\r\n  func: 'foo'\r\n  onComplete: ->\r\n    console.log \"mutation of foo() completed.\"\r\n\r\n    f = new Foo()\r\n    f.foo()\r\n```\r\n\r\n#### Static mutation of a source string (JavaScript Example)\r\n\r\n```JavaScript\r\nvar evolve = require(\"evolve\");\r\n\r\nvar old_src = \"x1 = 0; x2 = 42; f1 = function() { return x2 * 10; }; x1 = f1();\";\r\n\r\n// clone a source, with some \"dna\" copy errors\r\nevolve.clone({\r\n\r\n  // input source code (string)\r\n  \"src\" : old_src,\r\n\r\n  \"tentatives\": 1,\r\n\r\n  // on complete always return a source; In case of failure, the original is returned\r\n  \"onComplete\": function(src) { return console.log(\"finished: \" + src); }\r\n});\r\n\r\n```\r\n\r\n#### Static mutation of a source file (JavaScript example)\r\n \r\n The input file can be in .js or in .coffee\r\n\r\n```JavaScript\r\n  \r\n// read a file, with some \"dna\" copy errors\r\nevolve.readFile({\r\n    \"file\" : \"examples/evolvable.js\",\r\n    \"onComplete\": function(src) { return console.log(src); }\r\n});\r\n\r\n```\r\n\r\n#### Customization of globals\r\n\r\nJust pass a bunch of variables to be used in mutations.\r\nthese variables must be returned by a function,\r\nfor symbol name introspection to work\r\n\r\n```CoffeeScript\r\n\r\ncontext = -> [\r\n  Math.cos\r\n  Math.sin\r\n  Math.random\r\n  Math.PI\r\n]\r\n\r\n# then call it\r\nevolve.mutate context: context, .....\r\n```\r\n\r\n#### Customize the mutation rules\r\n\r\nFor the moment, please refer to the [sources](https://github.com/daizoru/node-evolve/blob/master/src/rules.coffee \"sources\") to see how rules work\r\n\r\n```CoffeeScript\r\nrules =\r\n\r\n  # decorators are applied on each node, and expected to return either\r\n  # the current, new or modified node, or an undefined value (then it is ignored)\r\n  decorators:\r\n    multiply: (t, value) -> \r\n      if t is 'num' and Math.random() < 0.5 then [t, Math.random() * value]\r\n\r\n\r\n```\r\n\r\n\r\n## Change log\r\n\r\n### 0.0.3\r\n\r\n  * more examples\r\n  * more doc\r\n\r\n### 0.0.2\r\n\r\n  * revert back to just the 'mutable' keyword\r\n  * various bigfixes\r\n  * more examples\r\n  * still slow as hell - maybe use another parsing library?\r\n\r\n### 0.0.1\r\n\r\n  * ?\r\n\r\n### 0.0.0\r\n\r\n  * initial commit\r\n\r\n## License (BSD)\r\n\r\n```plain\r\nCopyright (c) 2012, Julian Bilcke <julian.bilcke@daizoru.com>\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met: \r\n\r\n1. Redistributions of source code must retain the above copyright notice, this\r\n   list of conditions and the following disclaimer. \r\n2. Redistributions in binary form must reproduce the above copyright notice,\r\n   this list of conditions and the following disclaimer in the documentation\r\n   and/or other materials provided with the distribution. \r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\r\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\nThe views and conclusions contained in the software and documentation are those\r\nof the authors and should not be interpreted as representing official policies, \r\neither expressed or implied, of Julian Bilcke.\r\n```","note":"Don't delete this file! It's used internally to help with page regeneration."}